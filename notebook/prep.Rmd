---
title: "Directions for Implementing the Chessie BIBI"
output: html_notebook
---
**INTRODUCTION**  
This R-script and documentation is intended as a supplement to the [Smith et al. (2017) final report](https://www.potomacriver.org/wp-content/uploads/2017/05/ChessieBIBI_Report_Final_5-25-2017.pdf) and [appendices](https://www.potomacriver.org/wp-content/uploads/2017/05/ChessieBIBI_Appendix_Final_5-25-2017.pdf). Use these scripts to calculate the family-and bioregion- level “Chessie BIBI,” or Chesapeake Basin-wide Index of Biotic Integrity for streams and wadeable rivers in the Chesapeake Bay watershed.  

**1. DATA PREPARATION**   
Most macroinvertebrate assemblage data are formatted in a similar manner; however, rarely can data sets from two separate entities be joined without some manipulation. The data preparation functions outlined below manipulate the data to meet formatting requirements necessary for using the contained custom functions in the bibi2.0 and mmir packages. For any of the functions to be useful, the user must first properly prepare their data using the provided functions outlined below.  

(!!!CHECK THIS) Several columns must exist in every file uploaded, or the data preparation will fail: *STATION_ID*, *DATE*, *FINAL_ID*, and *REPORTING_VALUE*. If these four column headings are not present, the *data_prep* function will fail. Additionally, if the column heading *EVENT_ID* does not already exist, the *STATION_ID*, *DATE*, *AGENCY_CODE*, and *SAMPLE_NUMBER* are concatenated to form the *EVENT_ID*, a unique identifier to each sampling event that prevents data from being incorrectly aggregated. For example, data collected at the same station but on different dates will not be aggregated together during the preparation process because the *EVENT_ID*'s will be different due to the inclusion of *DATE*.  

The [Integrated Taxonomic Information System (ITIS)](https://www.itis.gov/) is an online database managed by federal agencies that attempts to provide the current taxonomic nomenclature. The Taxonomic Serial Number (TSN), a unique identification number assigned to each taxon, was also adopted from ITIS.gov. If the taxon was not found in ITIS but was valid based on a review of the literature, the taxon was assigned a unique negative integer. The negative integers will never overlap with the positive integers used by ITIS, allowing the table to accommodate additional taxa from ITIS without issue. The TSNs are reflected in the *TSN_FINAL* column in the Master Taxa List. It must also include a *FINAL_ID* column indicating the lowest taxonomic rank represented in a given row. Additionally, the Master Taxa List must contain each of the following taxonomic ranks: Phylum, Subphylum, Class, Subclass, Order, Suborder, Family, Subfamily, Tribe, Genus, Species.  Finally, if the user wants to calculate any of the metrics related to these taxonomic attributes, the table must also contain contain Tolerance Values (TV), Functional Feeding Groups (FFG), Habits, and Beck's Class.   

**1.1** Load the following packages into the environment.  

*mmir* is a custom package developed by Zachary Smith to calculate taxonomic community metrics. The development version can be downloaded from the [ICPRB GitHub account](https://github.com/InterstateCommissionPotomacRiverBasin/mmir) using `devtools::install_github(repo = "InterstateCommissionPotomacRiverBasin/mmir")`. After the installation, *mmir* must be loaded into the environment using `library()`.

*bibi2.0* is a custom package developed by Zachary Smith to automate the data preparation process. (HOW CAN OTHERS ACCESS?)
```{r}
library(tidyverse)
library(stringr)
library(lubridate)
library(mmir) 
library(bibi2.0) # Build in R Studio
library(odbc) # For Windows 64-bit; see 1.2
library(RODBC) # For Windows 32-bit; see 1.2
library(DBI)
library(magrittr)
library(vegan)
library(toolbox) # Download from Github (https://github.com/zsmith27/toolbox), then use: devtools::install_github("zsmith27/toolbox")
```
**1.2** Import the following tables from the Microsoft Access database. This process differs depending on which version of Windows, 64-bit or 32-bit, is installed. Both directions are outlined below. Then, the bibi2.0 function, `clean_data_frame()`, is implemented, setting all text to lowercase and removing unwanted spaces in the data. 
Windows 64-bit:
```{r}
channel <- dbConnect(odbc(), "CBIBI_2017")

tab.vec <- c("TAB_EVENT", 
             "TAB_STATIONS",
             "TAB_PROJECT",
             "TAB_WQ_DATA",
             "TAB_PARAMETER_WQ",
             "TAB_HABITAT_ASSESSMENT",
             "TAB_HABITAT_PARAMETERS",
             "TAB_TAXONOMIC_COUNT",
             "TAB_HUC_12",
             "TAB_PROGRAM",
             "TAB_MASTER_TAXA_LIST")

 tab.list <- purrr::map(tab.vec, function(tab.i) {
  dbReadTable(channel, tab.i, stringsAsFactors = FALSE) %>% 
    clean_data_frame()
}) %>% 
  set_names(tolower(tab.vec))

dbDisconnect(channel)
```
Windows 32-bit:
```{r eval=FALSE}
channel <- RODBC::odbcConnect("CBIBI_2017")

tab.vec <- c("TAB_EVENT", "TAB_STATIONS", "TAB_PROJECT",
            "TAB_WQ_DATA", "TAB_PARAMETER_WQ", "TAB_HABITAT_ASSESSMENT",
           "TAB_HABITAT_PARAMETERS", "TAB_TAXONOMIC_COUNT",
             "TAB_HUC_12", "TAB_PROGRAM", "TAB_MASTER_TAXA_LIST")

 tab.list <- purrr::map(tab.vec, function(tab.i) {
  RODBC::sqlFetch(channel, tab.i, stringsAsFactors = FALSE) %>% 
    clean_df()
}) %>% 
  set_names(tolower(tab.vec))

RODBC::odbcCloseAll()
```
**1.3** Join the Master Taxa List to the taxonomic count table using the *tsn_final* column. Then, apply the `prep_taxa()` function in the bibi2.0 package to perform taxa eclusions and roll-ups (Final Report Section B.iii).
```{r}
 tab.list$tab_taxonomic_count <- tab.list$tab_taxonomic_count %>% 
   dplyr::mutate(tsn_final = str_replace_all(tsn_final, "(?<![0-9])0+", "")) %>% 
   left_join(tab.list$tab_master_taxa_list, by = "tsn_final") %>% 
   prep_taxa() 
```
**1.4** Apply the `prep_data()` function from the bibi2.0 package to the indicated tables. Several prepping functions are nested within `prep_data()`:  

1) Water quality: select only specific conductivity, dissolved oxygen, and pH;  

2) Habitat: select only epifaunal substrate, bank stability, embeddedness, channel alteration, riffle/run/pool/ ratio, flow, bank vegetation, and sedimentation;   

3) Method: exclude samples collected from December to February; include only samples from 1^st^ - 4^th^ order streams; restrict the sampling method to kick-net or similar procedures.    

The output is `prep.df`, one large data frame which contains all of the taxa, water quality, and habitat data.  
```{r cache=TRUE}
prep.df <- prep_data(tab.list$tab_taxonomic_count,
                     tab.list$tab_wq_data,
                     tab.list$tab_habitat_assessment,
                     tab.list$tab_event,
                     tab.list$tab_stations,
                     tab.list$tab_project,
                     tab.list$tab_huc_12,
                     agg_sample_num = TRUE,
                     development = TRUE) # Should this be set to false?

rm(tab.list)
```
**1.5** Convert Functional Feeding Group (ffg) and Habit abbreviations to full names. This results in the addition of two new columns, *ffg* and *habit*, to `prep.df2`.
```{r}
prep.df2 <-
    dplyr::mutate(prep.df, ffg = case_when(
    is.na(bibi_ffg) | bibi_ffg == "" ~ as.character(NA),
    bibi_ffg == "cg" ~ "gather",
    bibi_ffg == "pr" ~ "predator",
    bibi_ffg == "sc" ~ "scrape",
    bibi_ffg == "cf" ~ "filter",
    bibi_ffg == "sh" ~ "shred",
    bibi_ffg == "om" ~ "omnivore",
    bibi_ffg == "pa" ~ "parasite",
    bibi_ffg %in% c("pc", "pi") ~ "pierce",
    TRUE ~ "ERROR"
  ),
  habit = case_when(
    is.na(bibi_habit) | bibi_habit == "" ~ as.character(NA),
    bibi_habit == "sp" ~ "sprawl",
    bibi_habit == "cn" ~ "cling",
    bibi_habit == "cb" ~ "climb",
    bibi_habit == "bu" ~ "burrow",
    bibi_habit == "sw" ~ "swim",
    bibi_habit == "sk" ~ "skate",
    TRUE ~ "ERROR"
  )
)
```

```{r eval = FALSE}
#Can be skipped; was for development.
site.class.df <- site_classification(prep.df) 
```
**1.6** Perform general cleaning of the data frame. The resulting data frame is `taxa.df`.
```{r cache=TRUE}
taxa.df <- prep.df2 %>% 
  ungroup() %>% 
  select(unique_id, icprb_bioregion_id, reporting_value,
         final_id, 
         phylum, subphylum, class, subclass,
         order, suborder, family, subfamily, tribe, genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup() %>% 
  fill_taxa(final_id, phylum:genus) %>% 
  mutate(final_id = genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup()
```
**1.7** Probabilistic rarefaction as described in Appendix D.  
A warning message will appear; however, this does not impact the rarefaction calculations.
```{r cache=TRUE}
taxa.df <- prob_rarefaction(taxa.df, unique_id, reporting_value, genus, 100)
```

```{r eval=FALSE}
# Can be skipped; was for development.
taxa.dev <- taxa.df %>% 
  filter(category %in% c("ref", "deg"))

metrics.df <- taxa.dev %>% 
  select(unique_id, category, icprb_bioregion_id) %>% 
  distinct()

metrics.df <- taxa_seq_parallel(taxa.dev, unique_id, reporting_value,
                                "order", "genus",
                                job = "pct") %>% 
  bind_cols(metrics.df)
```

```{r eval=FALSE}
#Can be skipped; was for development.
data.table::fwrite(metrics.df, "temp_metrics.csv")
```
**2. CALCULATE THE BIOLOGICAL METRICS**  
Once the data is in the proper format, the metrics can be calcualted quickly. The following scripts compute every metric for each of the 21,834 unique_id's. 
```{r}
non_rare <- prep.df2 %>% # non-rarefied data frame from above
   arrange(unique_id)

rare <- taxa.df %>%    # rarefied data frame from above
   arrange(unique_id) 

# Join rarefied and non-rarefied data (not sure that this will be useful)
DF2 <- rare %>%
  select(unique_id, rare_count)

joined_data <- left_join(non_rare, DF2, by="unique_id")
    
#  metrics.key.test <- non_rare %>%
 #   select(unique_id) %>%    # Checking to see if same # of unique_ids in rare and non_rare (yes); arrange to see if in same order (yes)
 #  distinct() %>%
#   arrange()
 
 # metrics.key2.test <- rare %>%  
 #  select(unique_id) %>%      # Checking to see if same # of unique_ids in rare and non_rare (yes); arrange to see if in same order (yes)
 # distinct() %>%
 # arrange()

metrics.key <- non_rare %>%
    ungroup %>%
    select(unique_id) %>%
    distinct()
 
metrics.key$aspt_mod <- taxa_tol_index(    # the two taxa_tol_index work
  long.df = non_rare,
  unique.id.col = unique_id,
  count.col = reporting_value,
  tol.col = aspt
)
metrics.key$hbi <- taxa_tol_index(
  long.df = non_rare,
  unique.id.col = unique_id,
  count.col = reporting_value,
  tol.col = bibi_tv
)

#################################################### Function to calc metrics
bio_fam_metrics <- function(x,y) {
   
   metrics.key <- non_rare %>%                # Metrics.key = df with all unique IDs and their corresponding ICPRB bioregions. Will build metrics onto.
    select(unique_id, icprb_bioregion_id) %>%
    unique() %>%
    arrange(unique_id) 
   
 metrics.key %>%
    dplyr::mutate(
aspt_mod = taxa_tol_index(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  tol.col = aspt
),
pct_gastro_oligo = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = class,
  taxon = c("gastropoda", "oligochatea")
),
pct_diptera = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = "diptera"
),
gold = 1 - (pct_gastro_oligo + pct_diptera),
hbi = taxa_tol_index(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  tol.col = bibi.tv
),
pct_arthropoda = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = phylum,
  taxon = "arthropda"
),
pct_burrow = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = habit, 
  taxon = "burrow" 
),
pct_chironomidae = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = family,
  taxon = "chironomidae"
),
pct_cling = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = habit,
  taxon = "cling"  
),
pct_burrow = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = habit,
  taxon = "burrow" 
),
pct_collect = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = ffg,
  taxon = c("filter", "gather")  
),
pct_cote = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = c("coleoptera",
            "odonata",
            "trichoptera",
            "ephemeroptera")
),
pct_ephemeroptera = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = "ephemeroptera"
),
pct_baetidae = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = family,
  taxon = "baetidae"
),
pct_ephemeroptera_no_baetid = pct_ephemeroptera - pct_baetidae,
pct_ept = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = c("ephemeroptera",
            "plecoptera",
            "trichoptera")
),
pct_hydropsychidae = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = family,
  taxon = "hydropsychidae"
),
pct_ept_no_hydro = pct_ept - pct_hydropsychidae,
pct_euholognatha = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = suborder,
  taxon = "euholognatha"
),
pct_filter = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = ffg,
  taxon = "filter"  
),
pct_heptageniidae = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = family,
  taxon = "heptageniidae"
),
pct_hexapoda = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = subphylum,
  taxon = "hexapoda"
),
pct_hydro_ept = ifelse(pct_ept == 0,
                       0,
                       (pct_hydropsychidae / pct_ept) * 100),
pct_intol_0_3 = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = bibi_tv,  # was tol_vol
  taxon = 0:3
),
pct_intol_0_4 = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = bibi_tv,
  taxon = 0:4
),
pct_amph_iso = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = c("amphipoda", "isopoda")
),
pct_ephemerellidae = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = family,
  taxon = "ephemerellidae"
),
pct_limestone = pct_amph_iso + pct_ephemerellidae,
pct_mod_tol_4_6 = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = bibi_tv,
  taxon = 4:6
),
pct_trichoptera = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = "trichoptera"
),
pct_non_hydrop_trichoptera = pct_trichoptera - pct_hydropsychidae,
pct_odonata = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = "odonata"
),
pct_pisciforma = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = suborder,
  taxon = "pisciforma"
),
pct_predator = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = ffg,
  taxon = "predator" 
),
pct_pterygota = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = subclass,
  taxon = "pterygota"
),
pct_retreat_caddisfly = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = suborder,
  taxon = "annulipalpia"
),
pct_scrape = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = ffg,
  taxon = "scrape" 
),
pct_sprawl = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = habit,
  taxon = "sprawl"  
),
pct_systellognatha = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = suborder,
  taxon = "systellognatha"
),
pct_tolerant_7_10 = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = bibi_tv,
  taxon = 7:10
),
pct_urban_intol = taxa_pct(
  long.df = x,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = suborder,
  taxon = c(
    "aeshnidae",
    "ameletidae",
    "asellidae",
    "athericidae",
    "baetidae",
    "brachycentridae",
    "caenidae",
    "calamoceratidae",
    "cambaridae",
    "capniidae",
    "ceratopogonidae",
    "chironomidae",
    "chloroperlidae",
    "cordulegastridae",
    "corduliidae",
    "corydalidae",
    "crangonyctidae",
    "elmidae",
    "ephemerellidae",
    "ephemeridae",
    "glossosomatidae",
    "gomphidae",
    "heptageniidae",
    "hydropsychidae",
    "hydroptilidae",
    "isonychiidae",
    "lepidostomatidae",
    "leptophlebiidae",
    "leuctridae",
    "libellulidae",
    "metretopodidae",
    "nemouridae",
    "odontoceridae",
    "peltoperlidae",
    "perlidae",
    "perlodidae",
    "philopotamidae",
    "phryganeidae",
    "polycentropodidae",
    "polymitarcyidae",
    "potamanthidae",
    "psephenidae",
    "pteronarcyidae",
    "rhyacophilidae",
    "sericostomatidae",
    "sialidae",
    "simuliidae",
    "stratiomyidae",
    "tabanidae",
    "taeniopterygidae",
    "tipulidae",
    "uenoidae",
    "viviparidae"
  )
),

# Richness/Diversity metrics require rarefied data.
margalefs = taxa_div(
  long.df = y,
  unique.id.col = unique_id,
  count.col = reporting_value,
  low.taxa.col = NULL,
  high.taxa.col = family,
  job = "margalef"
),
pct_ept_rich = taxa_pct_rich(
  long.df = y,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = c("ephemeroptera", "plecoptera", "trichotpera"),
  high.res.taxa.col = family,
  exclusion.col = NULL,
  exclusion.vec = NULL
),
pct_ept_rich_no_tol = taxa_pct_rich(
  long.df = y,
  unique.id.col = unique_id,
  count.col = reporting_value,
  taxon.col = order,
  taxon = c("ephemeroptera", "plecoptera", "trichotpera"),
  high.res.taxa.col = family,
  exclusion.col = bibi_tv,
  exclusion.vec = 7:10
),
pielou = taxa_div(
  long.df = y,
  unique.id.col = unique_id,
  count.col = reporting_value,
  low.taxa.col = NULL,
  high.taxa.col = family,
  job = "pielou"
),
rich_burrow = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = habit,
  high.taxa.col = family,
  taxon = "burrow"  
),
rich_climb = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = habit,
  high.taxa.col = family,
  taxon = "climb"  
),
rich_cling = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = habit,
  high.taxa.col = family,
  taxon = "cling"  
),
rich_collect = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = ffg,
  high.taxa.col = family,
  taxon = c("filter", "gather")
),
rich_ephemeroptera = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = order,
  high.taxa.col = family,
  taxon = "ephemeroptera"
),
rich_ept = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = habit,
  high.taxa.col = family,
  taxon = c("ephemeroptera",
            "plecoptera",
            "trichoptera")
),
rich_filter = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = ffg,
  high.taxa.col = family,
  taxon = "filter"  
),
rich_gather = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = ffg,
  high.taxa.col = family,
  taxon = "gather"   # cg
),
rich_intol = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = bibi_tv,
  high.taxa.col = family,
  taxon = 0:3
),
rich_modtol = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = bibi_tv,
  high.taxa.col = family,
  taxon = 4:6
),
rich_plecoptera = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = order,
  high.taxa.col = family,
  taxon = "plecoptera"
),
rich_predator = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = ffg,
  high.taxa.col = family,
  taxon = "predator"  
),
rich_shred = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = ffg,
  high.taxa.col = family,
  taxon = "shred"   
),
rich_sprawl = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = habit,
  high.taxa.col = family,
  taxon = "sprawl"  
),
rich_tol = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = bibi_tv,
  high.taxa.col = family,
  taxon = 7:10
),
rich_trichoptera = taxa_rich(
  long.df = y,
  unique.id.col = unique_id,
  low.taxa.col = order,
  high.taxa.col = family,
  taxon = "trichoptera"
)
)
return(metrics.key)
}

metrics.df <- bio_fam_metrics(non_rare, rare)
```
**5. METRIC SCORING**  
**5.1** Subset the data by bioregion.
```{r}
NAPU <- metrics.key %>%
  filter(icprb_bioregion_id == "napu")

NCA <- metrics.key %>%
  filter(icprb_bioregion_id == "nca")

CA <- metrics.key %>%
  filter(icprb_bioregion_id == "ca")

MAC<- metrics.key %>%
  filter(icprb_bioregion_id == "mac")

SEP <- metrics.key %>%
  filter(icprb_bioregion_id == "sep")
 
BLUE <- metrics.key %>%
  filter(icprb_bioregion_id == "blue")

NRV <- metrics.key %>%
  filter(icprb_bioregion_id == "nrv")

SRV <- metrics.key %>%
  filter(icprb_bioregion_id == "srv")

UNP <- metrics.key %>%
  filter(icprb_bioregion_id == "unp")

SGV <- metrics.key %>%
  filter(icprb_bioregion_id == "sgv")

LNP <- metrics.key %>%
  filter(icprb_bioregion_id == "lnp")

PIED <- metrics.key %>%
  filter(icprb_bioregion_id == "pied")
```
**5.2** Create a vector for each of the twelve bioregions that contains the names of the metrics specific to that bioregion.
```{r}
#Northern Appalachian Plateau and Uplands (NAPU)
NAPU_score <- NAPU %>%
  select(
  "unique_id",
  "margalefs", 
  "pct_cling",
  "pct_collect",
  "pct_ephemeroptera",
  "pct_ept",
  "pct_ept_no_hydro",
  "pct_ept_rich_no_tol",
  "pct_filter",
  "pct_intol_0_3",
  "pct_non_hydrop_trichoptera",
  "pct_predator",
  "pct_scrape",
  "pielou",
  "rich_burrow",
  "rich_cling",
  "rich_gather",
  "rich_modtol",
  "rich_plecoptera",
  "rich_shred",
  "rich_sprawl")
       
# North Central Appalachians (NCA)
NCA_score <- NCA %>%
  select(
    "unique_id",
    "aspt_mod",
    "pct_cote",
    "pct_ephemeroptera",
    "pct_heptageniidae",
    "pct_limestone",
    "rich_cling",
    "rich_ephemeroptera",
    "rich_ept",
    "rich_plecoptera")

# Central Appalachians (CA)
CA_score <- CA %>%
  select(
    "unique_id",
    "pct_ept_rich",
    "pct_euholognatha",
    "pct_heptageniidae",
    "pct_hydro_ept",
    "pct_mod_tol_4_6",
    "pct_non_hydrop_trichoptera",
    "pct_pisciforma",
    "pct_systellognatha",
    "rich_burrow",
    "rich_collect",
    "rich_filter",
    "rich_plecoptera",
    "rich_predator")

# Middle Atlantic Coastal Plain (MAC)
MAC_score <- MAC %>%
  select(
    "unique_id",
    "aspt_mod",
    "gold",
    "pct_arthropoda",
    "pct_chironomidae",
    "pct_collect",
    "pct_mod_tol_4_6",
    "pct_odonata",
    "pct_predator",
    "pct_scrape",
    "pct_urban_intol",
    "rich_climb",
    "rich_tol")

# Southeastern Plains (SEP)
SEP_score <- SEP %>%
  select(
    "unique_id",
    "aspt_mod",
    "gold",
    "hbi",
    "pct_cling",
    "pct_cote",
    "pct_ept_rich_no_tol",
    "rich_cling",
    "rich_collect",
    "rich_ephemeroptera",
    "rich_filter",
    "rich_tricoptera")

# Blue Ridge (BLUE)
BLUE_score <- BLUE %>% 
  select(
    "unique_id",
    "pct_burrow",
    "pct_ept_rich_no_tol",
    "pct_scrape",
    "pct_systellognatha",
    "rich_ephemeroptera")

# Northern Ridge and Valley (NRV)
NRV_score <- NRV %>%
  select(
    "unique_id",
    "aspt_mod",
    "pct_ephemeroptera_no_baetid",
    "pct_ept_rich",
    "rich_collect",
    "rich_ephemeroptera",
    "rich_predator",
    "rich_shred",
    "rich_tricoptera")

# Southern Ridge and Valley (SRV)
SRV_score <- SRV %>%
  select(
    "unique_id",
    "aspt_mod",
    "pct_burrow",
    "pct_cling",
    "pct_cote",
    "pct_ephemeroptera_no_baetid",
    "pct_ept_rich_no_tol",
    "pct_predator",
    "pct_scrape",
    "rich_cling",
    "rich_collect",
    "rich_ephemeroptera",
    "rich_intol",
    "rich_plecoptera",
    "rich_predator",
    "rich_trichoptera")

# Upper Northern Piedmont (UNP)
UNP_score <- UNP %>%
  select(
    "unique_id",
    "hbi",
    "pct_collect",
    "pct_ept_rich_no_tol",
    "pct_filter",
    "pct_hexapoda",
    "pct_pisciforma",
    "pct_retreat_caddisfly",
    "pct_scrape",
    "pct_urban_intol",
    "rich_ephemeroptera",
    "rich_plecoptera",
    "rich_trichoptera")

# Southern Great Valley (SGV)
SGV_score <- SGV %>%
  select(
    "unique_id",
    "aspt_mod",
    "gold",
    "pct_cling",
    "pct_collect",
    "pct_ephemeroptera_no_baetid",
    "pct_ept_no_hydro",
    "pct_ept_rich_no_tol",
    "pct_filter",
    "pct_heptageniidae",
    "pct_mod_tol_4_6",
    "pct_non_hydrop_trichoptera",
    "pct_pisciforma",
    "pct_predator",
    "pct_pterygota",
    "pct_scrape",
    "pct_sprawl",
    "pct_tolerant_7_10",
    "rich_collect",
    "rich_ephemeroptera",
    "rich_filter",
    "rich_trichoptera")

# Lower Northern Piedmont (LNP)
LNP_score <- LNP %>%
  select(
    "unique_id",
    "aspt_mod",
    "pct_cling",
    "pct_collect",
    "pct_ept_rich",
    "pct_mod_tol_4_6",
    "pct_predator",
    "pct_pterygota",
    "rich_cling",
    "rich_ephemeroptera")

# Piedmont (PIED)
PIED_score <- PIED %>%
  select(
    "unique_id",
    "pct_cling",
    "pct_ept_rich",
    "pct_intol_0_4",
    "pct_tolerant_7_10",
    "pct_urban_intol",
    "rich_cling",
    "rich_ephemeroptera",
    "rich_tricoptera")
```
**5.3** Score the metrics. The [Metric Thresholds](https://www.potomacriver.org/wp-content/uploads/2014/12/metric_thresholds_06292017.csv) table was used to determine whether a metric increased or decreased with disturbance, allowing for the selection of the correct scoring equation to use (Final Report, page 21). The Metric Thresholds table also contains *ref_median* and *bound* columns, which correspond to *X~M~* and *X~T~* in the equations, respectively.
```{r}





```
6. INDEX CONSTRUCTION
```{r}

```
7. INDEX CLASSIFICATION EFFICIENCY (BSP of index determined)
```{r}

```
9. NARRATIVE RATING CATEGORIES
```{r}

```
10. AREA-WEIGHTING OF RATING RESULTS
```{r}

```
