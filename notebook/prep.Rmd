---
title: "Directions for Implementing the Chessie BIBI"
output: html_notebook
---

**1. PREPARE THE DATA**

Install and open the following packages/datasets.
```{r}
library(tidyverse)
library(stringr)
library(lubridate)
library(mmir) # Download from Github (https://github.com/zsmith27/mmir), then use devtools::install_github("InterstateCommissionPotomacRiverBasin /mmir", ref = "dev", force = TRUE, quiet = TRUE)
library(bibi2.0) # Build in R Studio
# data("hier.fwmi")
# data("attributes.fwmi")
```
Import the data from your Access database.
```{r}

# USE THIS CODE IF YOU HAVE WINDOWS 64-BIT

library(odbc)
library(DBI)

channel <- dbConnect(odbc(), "CBIBI_2017")

tab.vec <- c("TAB_EVENT", "TAB_STATIONS", "TAB_PROJECT",
             "TAB_WQ_DATA", "TAB_PARAMETER_WQ", "TAB_HABITAT_ASSESSMENT",
             "TAB_HABITAT_PARAMETERS", "TAB_TAXONOMIC_COUNT",
             "TAB_HUC_12", "TAB_PROGRAM","TAB_MASTER_TAXA_LIST")

library(magrittr) 
tab.list <- purrr::map(tab.vec, function(tab.i) {
  dbReadTable(channel, tab.i, stringsAsFactors = FALSE) %>% 
    clean_data_frame()
}) %>% 
  set_names(tolower(tab.vec))

dbDisconnect(channel)

###########################################################################################

# USE THIS CODE IF YOU HAVE WINDOWS 32-BIT

# library(RODBC)
# channel <- RODBC::odbcConnect("CBIBI_2017")

#tab.vec <- c("TAB_EVENT", "TAB_STATIONS", "TAB_PROJECT",
#            "TAB_WQ_DATA", "TAB_PARAMETER_WQ", "TAB_HABITAT_ASSESSMENT",
#           "TAB_HABITAT_PARAMETERS", "TAB_TAXONOMIC_COUNT",
#             "TAB_HUC_12", "TAB_PROGRAM", "TAB_MASTER_TAXA_LIST")

# tab.list <- purrr::map(tab.vec, function(tab.i) {
#  RODBC::sqlFetch(channel, tab.i, stringsAsFactors = FALSE) %>% 
#    clean_df()
#}) %>% 
#  set_names(tolower(tab.vec))

#RODBC::odbcCloseAll()

```
Join the master taxa tab to the larger dataset using the tsn_final column as the key. Then, apply the prep_taxa package to remove certain taxa.
```{r}
 tab.list$tab_taxonomic_count <- tab.list$tab_taxonomic_count %>% 
   dplyr::mutate(tsn_final = str_replace_all(tsn_final, "(?<![0-9])0+", "")) %>% # in tsn_final, if there are 1 or more 0s not preceded by a 0-9, replace with " "
   left_join(tab.list$tab_master_taxa_list, by = "tsn_final") %>% 
   prep_taxa() # implement the prep taxa function (excluding some taxa and rolling up some)
```
Apply the prep_data package to the indicated tabs (includes water quality, habitat, method prep). Output dataframe is prep.df.
```{r cache=TRUE}
prep.df <- prep_data(tab.list$tab_taxonomic_count,
                     tab.list$tab_wq_data,
                     tab.list$tab_habitat_assessment,
                     tab.list$tab_event,
                     tab.list$tab_stations,
                     tab.list$tab_project,
                     tab.list$tab_huc_12,
                     agg_sample_num = TRUE,
                     development = TRUE)

rm(tab.list)
```
This can be skipped.
```{r eval = FALSE}
# site.class.df <- site_classification(prep.df) # think can skip
```
General cleaning of data; eliminating issues with duplicate values.
```{r cache=TRUE}
taxa.df <- prep.df %>% # if previous skipped, should be prep.df
  ungroup() %>% 
  select(unique_id, icprb_bioregion_id, reporting_value,  # Previously, "category" was located as the second object, but as it was a product of the previous code, delete
         final_id, 
         phylum, subphylum, class, subclass,
         order, suborder, family, subfamily, tribe, genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup() %>% 
  fill_taxa(final_id, phylum:genus) %>% 
  mutate(final_id = genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup()
```
Probabilistic rarefaction (from mmir package). A subset of 100 samples was selected for each agency. A warning about an rlang function being deprecated will
pop up; however, the rarefactions seems to run with no issues and the taxa.df dataframe is outputted.
```{r cache=TRUE}
library(vegan)
taxa.df <- prob_rarefaction(taxa.df, unique_id, reporting_value, genus, 100)
```
Can be skipped; was for development.
```{r eval=FALSE}
taxa.dev <- taxa.df %>% 
  filter(category %in% c("ref", "deg"))

metrics.df <- taxa.dev %>% 
  select(unique_id, category, icprb_bioregion_id) %>% 
  distinct()

metrics.df <- taxa_seq_parallel(taxa.dev, unique_id, reporting_value,
                                "order", "genus",
                                job = "pct") %>% 
  bind_cols(metrics.df)
```
Can be skipped; was for development.
```{r eval=FALSE}

data.table::fwrite(metrics.df, "temp_metrics.csv")
```
**2. CALCULATE THE BIOLOGICAL METRICS**
```{r}
library(toolbox) # Download from Github (https://github.com/zsmith27/toolbox), then use: devtools::install_github("zsmith27/toolbox")
library(tidyverse)



```
**3. CLASSIFY SITE CONDITIONS AS REFERENCE, MINIMALLY DEGRADED, MIXED, MODERATELY DEGRADED, or DEGRADED**
```{r}
site_classification <- function(long.df){
  
  final.df <- long.df %>%
    dplyr::mutate(
      deg_spcond = dplyr::case_when(
        spcond >= 1000 ~ 3,              # Specific conductivity scoring (0=reference site)
        spcond >= 750 ~ 2,
        spcond > 300 ~ 1,
        is.na(spcond) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_ph = dplyr::case_when(
        ph > 9.5 | ph < 4 ~ 3,           # pH scoring (0=reference site)
        ph > 8.5 | ph < 6 ~ 1,
        is.na(ph) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_do = dplyr::case_when(
        do <= 5 ~ 1,                     # Dissolved oxygen scoring (different scoring than 0=reference)
        is.na(do) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_hab = dplyr::case_when(            # Habitat scoring
        mean_hab >= 16 & na_hab <= 3 ~ 0,    
        mean_hab >= 14 & na_hab <= 3 ~ 1,
        mean_hab > 12 & na_hab <= 3 ~ 2,
        mean_hab <= 12 & na_hab <= 3 ~ 3,
        TRUE ~ as.numeric(NA)
      ),
      deg_wq = deg_spcond + deg_ph + deg_do,   # scoring using all conditions
      category = dplyr::case_when(
        deg_wq == 0 & hab_16 == (8 - na_hab) ~ "ref", #"ref_plus",
        deg_wq == 0 & hab_16 / (8 - na_hab) * 100 >= 75 & hab_12 == 0 ~ "ref",
        deg_wq == 0 & hab_16 / (8 - na_hab) * 100 >= 66 ~ "min",
        deg_wq == 0 & hab_12 / (8 - na_hab) * 100 >= 50 ~ "mod",
        deg_wq > 0 | hab_6 / (8 - na_hab) * 100 >= 50 ~ "deg",
        8 - na_hab < 3 ~ "mix",
        TRUE ~ "mix"
      )
    )

  return(final.df)
}
```
4. SPATIAL CLASSIFICATION ??
```{r}

```
5. METRIC TESTING
```{r}

```
6. METRIC SCORING
```{r}

```
7. INDEX CONSTRUCTION
```{r}

```
8. INDEX CLASSIFICATION EFFICIENCY (BSP of index determined)
```{r}

```
9. DELETE-D JACKNIFE VALIDATION AND PRECISION
```{r}

```
10. NARRATIVE RATING CATEGORIES
```{r}

```
11. AREA-WEIGHTING OF RATING RESULTS
```{r}

```
