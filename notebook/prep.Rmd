---
title: "Directions for Implementing the Chessie BIBI"
output: html_notebook
---

**1. PREPARE THE DATA**

Install and open the following packages/datasets.
```{r}
library(tidyverse)
library(stringr)
library(lubridate)
library(mmir) # Download from Github (https://github.com/zsmith27/mmir), then use devtools::install_github("InterstateCommissionPotomacRiverBasin /mmir", ref = "dev", force = TRUE, quiet = TRUE)
library(bibi2.0) # Build in R Studio
# data("hier.fwmi")
# data("attributes.fwmi")
```
Import the data from your Access database.
```{r}

# USE THIS CODE IF YOU HAVE WINDOWS 64-BIT

library(odbc)
library(DBI)

channel <- dbConnect(odbc(), "CBIBI_2017")

tab.vec <- c("TAB_EVENT", "TAB_STATIONS", "TAB_PROJECT",
             "TAB_WQ_DATA", "TAB_PARAMETER_WQ", "TAB_HABITAT_ASSESSMENT",
             "TAB_HABITAT_PARAMETERS", "TAB_TAXONOMIC_COUNT",
             "TAB_HUC_12", "TAB_PROGRAM","TAB_MASTER_TAXA_LIST")

library(magrittr) 
tab.list <- purrr::map(tab.vec, function(tab.i) {
  dbReadTable(channel, tab.i, stringsAsFactors = FALSE) %>% 
    clean_data_frame()
}) %>% 
  set_names(tolower(tab.vec))

dbDisconnect(channel)

###########################################################################################

# USE THIS CODE IF YOU HAVE WINDOWS 32-BIT

# library(RODBC)
# channel <- RODBC::odbcConnect("CBIBI_2017")

#tab.vec <- c("TAB_EVENT", "TAB_STATIONS", "TAB_PROJECT",
#            "TAB_WQ_DATA", "TAB_PARAMETER_WQ", "TAB_HABITAT_ASSESSMENT",
#           "TAB_HABITAT_PARAMETERS", "TAB_TAXONOMIC_COUNT",
#             "TAB_HUC_12", "TAB_PROGRAM", "TAB_MASTER_TAXA_LIST")

# tab.list <- purrr::map(tab.vec, function(tab.i) {
#  RODBC::sqlFetch(channel, tab.i, stringsAsFactors = FALSE) %>% 
#    clean_df()
#}) %>% 
#  set_names(tolower(tab.vec))

#RODBC::odbcCloseAll()

```
Join the master taxa tab to the larger dataset using the tsn_final column as the key. Then, apply the prep_taxa package to remove certain taxa.
```{r}
 tab.list$tab_taxonomic_count <- tab.list$tab_taxonomic_count %>% 
   dplyr::mutate(tsn_final = str_replace_all(tsn_final, "(?<![0-9])0+", "")) %>% 
   left_join(tab.list$tab_master_taxa_list, by = "tsn_final") %>% 
   prep_taxa() # implement the prep taxa function (excluding some taxa and rolling up some)
```
Apply the prep_data package to the indicated tabs (includes water quality, habitat, method prep). Output dataframe is prep.df.
```{r cache=TRUE}
prep.df <- prep_data(tab.list$tab_taxonomic_count,
                     tab.list$tab_wq_data,
                     tab.list$tab_habitat_assessment,
                     tab.list$tab_event,
                     tab.list$tab_stations,
                     tab.list$tab_project,
                     tab.list$tab_huc_12,
                     agg_sample_num = TRUE,
                     development = TRUE)

rm(tab.list)
```
Change ffg and habit codes to names.
```{r}
prep.df2 <-
    dplyr::mutate(prep.df, ffg = case_when(
    is.na(bibi_ffg) | bibi_ffg == "" ~ as.character(NA),
    bibi_ffg == "cg" ~ "gather",
    bibi_ffg == "pr" ~ "predator",
    bibi_ffg == "sc" ~ "scrape",
    bibi_ffg == "cf" ~ "filter",
    bibi_ffg == "sh" ~ "shred",
    bibi_ffg == "om" ~ "omnivore",
    bibi_ffg == "pa" ~ "parasite",
    bibi_ffg %in% c("pc", "pi") ~ "pierce",
    TRUE ~ "ERROR"
  ),
  habit = case_when(
    is.na(bibi_habit) | bibi_habit == "" ~ as.character(NA),
    bibi_habit == "sp" ~ "sprawl",
    bibi_habit == "cn" ~ "cling",
    bibi_habit == "cb" ~ "climb",
    bibi_habit == "bu" ~ "burrow",
    bibi_habit == "sw" ~ "swim",
    bibi_habit == "sk" ~ "skate",
    TRUE ~ "ERROR"
  )
)
```
This can be skipped.
```{r eval = FALSE}
# site.class.df <- site_classification(prep.df) # think can skip
```
General cleaning of data; eliminating issues with duplicate values.
```{r cache=TRUE}
taxa.df <- prep.df2 %>% # if previous skipped, should be prep.df2
  ungroup() %>% 
  select(unique_id, icprb_bioregion_id, reporting_value,  # Previously, "category" was located as the second object, but as it was a product of the previous code, delete
         final_id, 
         phylum, subphylum, class, subclass,
         order, suborder, family, subfamily, tribe, genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup() %>% 
  fill_taxa(final_id, phylum:genus) %>% 
  mutate(final_id = genus) %>% 
  group_by_at(vars(-reporting_value)) %>% 
  summarize(reporting_value = sum(reporting_value)) %>% 
  ungroup()
```
Probabilistic rarefaction (from mmir package). A subset of 100 samples was selected for each agency. A warning about an rlang function being deprecated will
pop up; however, the rarefactions seems to run with no issues and the taxa.df dataframe is outputted.
```{r cache=TRUE}
library(vegan)
taxa.df <- prob_rarefaction(taxa.df, unique_id, reporting_value, genus, 100)
```
Can be skipped; was for development.
```{r eval=FALSE}
taxa.dev <- taxa.df %>% 
  filter(category %in% c("ref", "deg"))

metrics.df <- taxa.dev %>% 
  select(unique_id, category, icprb_bioregion_id) %>% 
  distinct()

metrics.df <- taxa_seq_parallel(taxa.dev, unique_id, reporting_value,
                                "order", "genus",
                                job = "pct") %>% 
  bind_cols(metrics.df)
```
Can be skipped; was for development.
```{r eval=FALSE}

data.table::fwrite(metrics.df, "temp_metrics.csv")
```
**2. CALCULATE THE BIOLOGICAL METRICS**
Metrics have already been tested, and a subset of the the most suitable ones have been determined. 
Use the following code to calculate the subsetted metrics. 
```{r}
library(toolbox) # Download from Github (https://github.com/zsmith27/toolbox), then use: devtools::install_github("zsmith27/toolbox")
library(tidyverse)

non_rare <- prep.df2 # non-rarefied data
rare <- taxa.df      # rarefied data
# reference ---------------------------------------------------------------
met.thresh.df <-
  data.table::fread("C:/Users/RJepson/Desktop/metric_thresholds.csv") %>%
  toolbox::prep_df() %>%
  filter(
    taxonomic_resolution == "family",
    !spatial_resolution %in% c("basin", "inland", "coast")
  ) %>%
  arrange(taxonomic_resolution, metric)

metrics <- sort(unique(met.thresh.df$metric))

# Calculate all the metrics ------------------------------------------------------------
bio_fam_metrics <- function(x,y) {
  metrics.key <- metrics %>%
    select(unique_id) %>%
    distinct()

 metrics.key %>%
    dplyr::mutate(
      aspt_mod = taxa_tol_index(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        tol.col = aspt
      ),
      pct_gastro_oligo = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = class,
        taxon = c("gastropoda", "oligochatea")
      ),
      pct_diptera = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = "diptera"
      ),
      gold = 1 - (pct_gastro_oligo + pct_diptera),
      hbi = taxa_tol_index(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        tol.col = bibi.tv
      ),
      pct_arthropoda = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = phylum,
        taxon = "arthropda"
      ),
      pct_burrow = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = habit, 
        taxon = "burrow" 
      ),
      pct_chironomidae = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = family,
        taxon = "chironomidae"
      ),
      pct_cling = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = habit,
        taxon = "cling"  
      ),
      pct_burrow = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = habit,
        taxon = "burrow" 
      ),
      pct_collect = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = ffg,
        taxon = c("filter", "gather")  
      ),
      pct_cote = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = c("coleoptera",
                  "odonata",
                  "trichoptera",
                  "ephemeroptera")
      ),
      pct_ephemeroptera = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = "ephemeroptera"
      ),
      pct_baetidae = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = family,
        taxon = "baetidae"
      ),
      pct_ephemeroptera_no_baetid = pct_ephemeroptera - pct_baetidae,
      pct_ept = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = c("ephemeroptera",
                  "plecoptera",
                  "trichoptera")
      ),
      pct_hydropsychidae = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = family,
        taxon = "hydropsychidae"
      ),
      pct_ept_no_hydro = pct_ept - pct_hydropsychidae,
      pct_euholognatha = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = suborder,
        taxon = "euholognatha"
      ),
      pct_filter = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = ffg,
        taxon = "filter"  
      ),
      pct_heptageniidae = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = family,
        taxon = "heptageniidae"
      ),
      pct_hexapoda = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = subphylum,
        taxon = "hexapoda"
      ),
      pct_hydro_ept = ifelse(pct_ept == 0,
                             0,
                             (pct_hydropsychidae / pct_ept) * 100),
      pct_intol_0_3 = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = bibi_tv,  # was tol_vol
        taxon = 0:3
      ),
      pct_intol_0_4 = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = bibi_tv,
        taxon = 0:4
      ),
      pct_amph_iso = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = c("amphipoda", "isopoda")
      ),
      pct_ephemerellidae = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = family,
        taxon = "ephemerellidae"
      ),
      pct_limestone = pct_amph_iso + pct_ephemerellidae,
      pct_mod_tol_4_6 = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = bibi_tv,
        taxon = 4:6
      ),
      pct_trichoptera = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = "trichoptera"
      ),
      pct_non_hydrop_trichoptera = pct_trichoptera - pct_hydropsychidae,
      pct_odonata = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = "odonata"
      ),
      pct_pisciforma = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = suborder,
        taxon = "pisciforma"
      ),
      pct_predator = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = ffg,
        taxon = "predator" 
      ),
      pct_pterygota = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = subclass,
        taxon = "pterygota"
      ),
      pct_retreat_caddisfly = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = suborder,
        taxon = "annulipalpia"
      ),
      pct_scrape = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = ffg,
        taxon = "scrape" 
      ),
      pct_sprawl = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = habit,
        taxon = "sprawl"  
      ),
      pct_systellognatha = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = suborder,
        taxon = "systellognatha"
      ),
      pct_tolerant_7_10 = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = bibi_tv,
        taxon = 7:10
      ),
      pct_urban_intol = taxa_pct(
        long.df = x,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = suborder,
        taxon = c(
          "aeshnidae",
          "ameletidae",
          "asellidae",
          "athericidae",
          "baetidae",
          "brachycentridae",
          "caenidae",
          "calamoceratidae",
          "cambaridae",
          "capniidae",
          "ceratopogonidae",
          "chironomidae",
          "chloroperlidae",
          "cordulegastridae",
          "corduliidae",
          "corydalidae",
          "crangonyctidae",
          "elmidae",
          "ephemerellidae",
          "ephemeridae",
          "glossosomatidae",
          "gomphidae",
          "heptageniidae",
          "hydropsychidae",
          "hydroptilidae",
          "isonychiidae",
          "lepidostomatidae",
          "leptophlebiidae",
          "leuctridae",
          "libellulidae",
          "metretopodidae",
          "nemouridae",
          "odontoceridae",
          "peltoperlidae",
          "perlidae",
          "perlodidae",
          "philopotamidae",
          "phryganeidae",
          "polycentropodidae",
          "polymitarcyidae",
          "potamanthidae",
          "psephenidae",
          "pteronarcyidae",
          "rhyacophilidae",
          "sericostomatidae",
          "sialidae",
          "simuliidae",
          "stratiomyidae",
          "tabanidae",
          "taeniopterygidae",
          "tipulidae",
          "uenoidae",
          "viviparidae"
        )
      ),
      # Richness/Diversity metrics require rarefied data.
      margalefs = taxa_div(
        long.df = y,
        unique.id.col = unique_id,
        count.col = reporting_value,
        low.taxa.col = NULL,
        high.taxa.col = family,
        job = "margalef"
      ),
      pct_ept_rich = taxa_pct_rich(
        long.df = y,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = c("ephemeroptera", "plecoptera", "trichotpera"),
        high.res.taxa.col = family,
        exclusion.col = NULL,
        exclusion.vec = NULL
      ),
      pct_ept_rich_no_tol = taxa_pct_rich(
        long.df = y,
        unique.id.col = unique_id,
        count.col = reporting_value,
        taxon.col = order,
        taxon = c("ephemeroptera", "plecoptera", "trichotpera"),
        high.res.taxa.col = family,
        exclusion.col = bibi_tv,
        exclusion.vec = 7:10
      ),
      pielou = taxa_div(
        long.df = y,
        unique.id.col = unique_id,
        count.col = reporting_value,
        low.taxa.col = NULL,
        high.taxa.col = family,
        job = "pielou"
      ),
      rich_burrow = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = habit,
        high.taxa.col = family,
        taxon = "burrow"  
      ),
      rich_climb = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = habit,
        high.taxa.col = family,
        taxon = "climb"  
      ),
      rich_cling = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = habit,
        high.taxa.col = family,
        taxon = "cling"  
      ),
      rich_collect = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = ffg,
        high.taxa.col = family,
        taxon = c("filter", "gather")
      ),
      rich_ephemeroptera = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = order,
        high.taxa.col = family,
        taxon = "ephemeroptera"
      ),
      rich_ept = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = habit,
        high.taxa.col = family,
        taxon = c("ephemeroptera",
                  "plecoptera",
                  "trichoptera")
      ),
      rich_filter = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = ffg,
        high.taxa.col = family,
        taxon = "filter"  
      ),
      rich_gather = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = ffg,
        high.taxa.col = family,
        taxon = "gather"   # cg
      ),
      rich_intol = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = bibi_tv,
        high.taxa.col = family,
        taxon = 0:3
      ),
      rich_modtol = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = bibi_tv,
        high.taxa.col = family,
        taxon = 4:6
      ),
      rich_plecoptera = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = order,
        high.taxa.col = family,
        taxon = "plecoptera"
      ),
      rich_predator = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = ffg,
        high.taxa.col = family,
        taxon = "predator"  
      ),
      rich_shred = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = ffg,
        high.taxa.col = family,
        taxon = "shred"   
      ),
      rich_sprawl = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = habit,
        high.taxa.col = family,
        taxon = "sprawl"  
      ),
      rich_tol = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = bibi_tv,
        high.taxa.col = family,
        taxon = 7:10
      ),
      rich_trichoptera = taxa_rich(
        long.df = y,
        unique.id.col = unique_id,
        low.taxa.col = order,
        high.taxa.col = family,
        taxon = "trichoptera"
      )
    )
  return(metrics.key)
}

f.df <- bio_fam_metrics(non_rare, rare)

```
**3. CLASSIFY SITE CONDITIONS AS REFERENCE, MINIMALLY DEGRADED, MIXED, MODERATELY DEGRADED, or DEGRADED**
```{r}
site_classification <- function(long.df){
  
  final.df <- long.df %>%
    dplyr::mutate(
      deg_spcond = dplyr::case_when(
        spcond >= 1000 ~ 3,              # Specific conductivity scoring (0=reference site)
        spcond >= 750 ~ 2,
        spcond > 300 ~ 1,
        is.na(spcond) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_ph = dplyr::case_when(
        ph > 9.5 | ph < 4 ~ 3,           # pH scoring (0=reference site)
        ph > 8.5 | ph < 6 ~ 1,
        is.na(ph) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_do = dplyr::case_when(
        do <= 5 ~ 1,                     # Dissolved oxygen scoring (different scoring than 0=reference)
        is.na(do) ~ as.numeric(NA),
        TRUE ~ 0
      ),
      deg_hab = dplyr::case_when(            # Habitat scoring
        mean_hab >= 16 & na_hab <= 3 ~ 0,    
        mean_hab >= 14 & na_hab <= 3 ~ 1,
        mean_hab > 12 & na_hab <= 3 ~ 2,
        mean_hab <= 12 & na_hab <= 3 ~ 3,
        TRUE ~ as.numeric(NA)
      ),
      deg_wq = deg_spcond + deg_ph + deg_do,   # scoring using all conditions
      category = dplyr::case_when(
        deg_wq == 0 & hab_16 == (8 - na_hab) ~ "ref", #"ref_plus",
        deg_wq == 0 & hab_16 / (8 - na_hab) * 100 >= 75 & hab_12 == 0 ~ "ref",
        deg_wq == 0 & hab_16 / (8 - na_hab) * 100 >= 66 ~ "min",
        deg_wq == 0 & hab_12 / (8 - na_hab) * 100 >= 50 ~ "mod",
        deg_wq > 0 | hab_6 / (8 - na_hab) * 100 >= 50 ~ "deg",
        8 - na_hab < 3 ~ "mix",
        TRUE ~ "mix"
      )
    )

  return(final.df)
}
```
4. SPATIAL CLASSIFICATION ??
```{r}

```
5. METRIC SCORING
```{r}

```
6. INDEX CONSTRUCTION
```{r}

```
7. INDEX CLASSIFICATION EFFICIENCY (BSP of index determined)
```{r}

```
8. DELETE-D JACKNIFE VALIDATION AND PRECISION
```{r}

```
9. NARRATIVE RATING CATEGORIES
```{r}

```
10. AREA-WEIGHTING OF RATING RESULTS
```{r}

```
